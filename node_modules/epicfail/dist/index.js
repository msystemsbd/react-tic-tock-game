"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.log = exports.fail = exports.EpicfailError = void 0;
const chalk_1 = __importDefault(require("chalk"));
const terminal_link_1 = __importDefault(require("terminal-link"));
const envinfo_1 = require("./envinfo");
const github_1 = require("./github");
const json_1 = require("./json");
const term_1 = require("./term");
class EpicfailError extends Error {
    constructor(message, option = {}) {
        super(message);
        this.epicfail = option;
    }
}
exports.EpicfailError = EpicfailError;
function fail(message, Option = {}) {
    throw new EpicfailError(message instanceof Error ? message.message : message, Option);
}
exports.fail = fail;
function log(message, option = { stacktrace: false, message: false, env: false }) {
    fail(message, option);
}
exports.log = log;
function handleErrors(cliFlags = {}) {
    const pkgPath = json_1.getModulePackagePath(module.parent.filename);
    if (!pkgPath)
        throw new Error('Could not find package.json for the module.');
    const handleError = (err, ...rest) => __awaiter(this, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e;
        // handle error
        if (!(err instanceof Error)) {
            err = new Error(JSON.stringify(err, null, 2));
        }
        const { stacktrace = true, issues = false, message = true, env, onError, assertExpected = () => false, } = Object.assign(Object.assign({}, cliFlags), ((_a = err.epicfail) !== null && _a !== void 0 ? _a : {}));
        if (yield Promise.resolve(assertExpected(err))) {
            return log(err);
        }
        const stash = new term_1.Stash();
        const pkg = json_1.readJSON(pkgPath);
        const reporterURL = (_e = (_d = (_c = (_b = pkg === null || pkg === void 0 ? void 0 : pkg.bugs) === null || _b === void 0 ? void 0 : _b.url) !== null && _c !== void 0 ? _c : pkg === null || pkg === void 0 ? void 0 : pkg.bugs) !== null && _d !== void 0 ? _d : pkg === null || pkg === void 0 ? void 0 : pkg.homepage) !== null && _e !== void 0 ? _e : pkg === null || pkg === void 0 ? void 0 : pkg.author;
        const repo = github_1.guessRepo(reporterURL);
        const eventID = onError ? onError(err, ...rest) : undefined;
        // show error message
        stash.push(renderError(err));
        // show stack trace
        if (stacktrace && err.stack) {
            stash.push(renderStacktrace(err.stack), { extra: true });
        }
        // show additional env info
        if (env !== false) {
            stash.push(yield renderEnv(env, pkg));
        }
        // search related issues
        if (issues && repo) {
            const res = yield renderIssues(err.message, repo);
            if (res)
                stash.push(res);
        }
        // guide to bug tracker
        if (message && reporterURL) {
            stash.push(renderBugTracker(reporterURL, stash, repo, eventID));
        }
        stash.render();
    });
    process.on('unhandledRejection', handleError);
    process.on('uncaughtException', handleError);
}
exports.default = handleErrors;
function renderError(err) {
    const title = err.name;
    return ((title !== 'Error' ? term_1.makeTitle(chalk_1.default.red, title) + '\n' : '') +
        chalk_1.default.red(err.message));
}
function renderStacktrace(stack) {
    return chalk_1.default.gray(`
\`\`\`
${stack}
\`\`\``);
}
function renderEnv(env, pkg) {
    return __awaiter(this, void 0, void 0, function* () {
        return '\n' + (yield envinfo_1.genEnv(env, pkg));
    });
}
function renderIssues(message, repo) {
    return __awaiter(this, void 0, void 0, function* () {
        const issues = yield github_1.findIssues(message, repo);
        let res = [];
        if (issues && issues.length > 0) {
            res.push('\n' + term_1.makeTitle(chalk_1.default.white, 'Issues'));
            res.push(issues
                .map((issue) => `${chalk_1.default.green(`#${issue.number}`)} ${issue.title}`)
                .join('\n'));
        }
        return res.join('\n') || undefined;
    });
}
function renderBugTracker(reporterURL, stash, repo, eventID) {
    let detailedURL = reporterURL;
    if (repo) {
        let link = github_1.linkToNewIssue(repo, stash.toString());
        if (link.length > 2000)
            link = github_1.linkToNewIssue(repo, stash.toString({ extra: false }));
        detailedURL = link;
    }
    return `\nIf you think this is a bug, please report at ${terminal_link_1.default(chalk_1.default.yellow(reporterURL), detailedURL, { fallback: false })} along with the information above${eventID ? ` and event id ${chalk_1.default.bold.magenta(eventID)}` : ''}.`;
}
